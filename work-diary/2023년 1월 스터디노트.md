# 2023-01-02
## 재귀 함수
https://velog.io/@jangws/JS-%EC%9E%AC%EA%B7%80%ED%95%A8%EC%88%98%EB%A1%9C-%EB%B0%B0%EC%97%B4%EC%9D%84-%ED%8A%B8%EB%A6%AC%EA%B5%AC%EC%A1%B0%EB%A1%9C-%EC%B6%9C%EB%A0%A5%ED%95%98%EA%B8%B0

# 2023-01-04
## 트리 만들기
```js
const arrayToTree = (arr) => {
  let tempResult = {},
    roots = []
    
  const getTreeFunc = () => {
      arr.forEach((el, i) => {
        tempResult[el.dirId] = i;
        el.children = [];
        if (el.dirPid !== -1) {
          arr[tempResult[el.dirPid]].children.push(el);
        } else {
          roots.push(el);
        };
      });
    }
  getTreeFunc();
  return roots;
};

arrayToTree(data);

```

# 2023-01-05 
## 트리 완성
```js
const arrayToTree = (arr) => {
  let tempResult = {},
    // 가장 상위가 될 root
    roots = [];

  // 각 값들을 체크하며 tree를 만들어주는 함수
  const getTreeFunc = () => {
    arr.forEach((el, i) => {
      // dirId에 index를 할당한다. 즉, dirId가 data array에서 가지는 위치를 나타내게 된다.
      tempResult[el.dirId] = i;
      // console.log(tempResult);

      // 요소에 children, state 프로퍼티를 추가한다.
      el.children = [];
      el.state = { expand: false, selected: 0, treeLevel: 0 };

      // dirPid가 -1이 아닐 경우
      if (el.dirPid !== -1) {
        // tempResult에 dirId의 index가 할당되어 있다. 따라서 parentIndex는 자신이 자식이 될 부모의 Index를 나타낸다.
        const parentIndex = tempResult[el.dirPid];

        // 자신이 자식이 될 부모 요소를 나타낸다.
        const parent = arr[parentIndex];

        // 자식의 treeLevel은 부모 treeLevel + 1이다.
        el.state.treeLevel = parent.state.treeLevel + 1;

        // 부모에 자기 자신을 밀어 넣는다!
        arr[parentIndex].children.push(el);
      } else {
        // dirPid가 -1일 경우, 자기 자신을 루트에 집어넣는다.
        roots.push(el);
      }
    });
  };
  getTreeFunc();
  // 루트를 반환한다.
  return roots;
};
arrayToTree(data);
```
