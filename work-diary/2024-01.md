# 2024-01-23
## `Map` 객체를 이용한 데이터 내 배열 업데이트
### 사용 상황
- `example/result (GET)를 호출했을 때의 apiResult.data.list의 개별 아이템 데이터타입 I_ResourceInfo이다.
```ts
interface I_AssigneeInfo {
  userId: string;
  userNo: number;
  userName: string;
  userEmail: string;
  isDeletable: 1 | 0;
}

export interface I_ResourceInfo {
  typeNo: number;
  nameNo: number;
  groupNo: number;
  id: string;
  uniqueAssigneeInfo: I_AssigneeInfo[];
}

```
 - `example/result (GET)`을 통해 불러오는 데이터 중, `uniqueAssigneeInfo`에는 `isDeletable` 값은 각각 다르지만 나머지 값(`userId`, `userNo`, `userName`, `userEmail`)은 같은 데이터들이 있다.
- 해당 데이터를 `userNo` 기준으로 중복을 삭제하되, `isDeletable` 값이 `0`인 것들을 우선적으로 남겨두고 `isDeletable` 값이 `1`인 것들을 삭제해야 한다.
- 결론: `apiResult.data.list`로 불러오는 배열의 데이터를 재구성한다. -> 각 데이터의 `uniqueAssigneeInfo`의 중복을 `userNo` 기준으로 지우되, `isDeletable` 값이 `0`인 것들을 남겨둬야 함.


### 방법
- **Map 데이터타입을 이용한 중복 제거**
```tsx
import axios from 'axios';

// 데이터 로드 및 처리 함수
const loadResourceData = async () => {
  try {
    const apiResult = await axios.get('example/result', {
      params: queryParameters, // 요청에 포함될 쿼리 파라미터
      // 필요시 여기에 추가 axios 설정 삽입
    });

    const transformedList = apiResult.data.list.map((entry) => ({
      ...entry,
      isSelected: { selected: false },
      uniqueAssigneeInfo: Array.from(
        entry.fixManagerInfo.reduce((accumulator, assignee) => {
          if (!accumulator.has(assignee.userNo) || accumulator.get(assignee.userNo).isDeletable > assignee.isDeletable) {
            accumulator.set(assignee.userNo, assignee);
          }
          return accumulator;
        }, new Map()).values()
      ),
    }));

    updateState({ action: 'updatePagination', details: apiResult.data.paging }); // 예시: 응답 데이터에 포함된 페이지 정보
    updateState({ action: 'refreshList', details: transformedList });
  } catch (error) {
    console.error('Error fetching data from API:', error);
    // 오류 처리
  }
};

loadResourceData(); // 함수 호출
```

### 코드 설명
- `Array.from()`: `reduce`를 통해 반환된 `Map` iterator를 배열로 만든다.
- `entry.uniqueAssigneeInfo.reduce`는 `uniqueAssigneeInfo`를 순회하며, `userNo`를 기준으로 중복을 제거하는 역할을 한다.
- 초기값 `new Map()`: `userNo`를 키, `assignee` 객체를 값으로 하는 `Map`을 생성한다.
- 여기서 `Map`은 키의 유일성을 보장하기 때문에, `userNo`를 기준으로 중복을 제거할 수 있다.


## Map 타입에 대해 알아보기
### 정의
- `Map` 객체 : JS에서 키-값 쌍을 저장하는 데 사용되는 컬렉션.
- `Map`은 어떤 타입의 값이든 **key**로 사용할 수 있다.
- `Map`은 순서가 유지되는 키-값 쌍의 집합으로, 삽입된 순서대로 각 요소를 반복할 수 있다.

  ### 특징
  - 키의 유일성 : `Map`내에서 키는 유일하다. 새 키-값 쌍을 추가할 때 이미 같은 키가 존재한다면, 기존의 키-값 쌍이 새로운 값으로 대체된다.
  - 값의 다양성 : `Map`의 키과 값으로는 모든 **타입의 값** (원시 값, 객체 등)을 사용할 수 있다.
  - 순서 보장 : 삽입된 순서대로 키-값 쌍을 반복할 수 있다. (이는 일반적 개체와의 차이점이다.)
  - 직접적 크기 접근 : `Map.size` 속성을 통해 `Map`내 요소의 수를 직접 알 수 있따.
 
  ### 메서드
  - `set(key, value)` : `Map`에 키-값 쌍을 추가한다. 이미 존재하는 키에 대해 호출하면, 해당 키값이 업데이트된다.
  - `get(key)`: 지정한 키에 대한 값을 반환한다. (만약 key가 존재하지 않을 경우, undefined 반환)
  - `has(key)`: `Map`이 지정한 키를 포함하고 있는지 여부를 나타내는 불리언 값 반환.
  - `delete(key)`: 지정한 키를 가진 요소를 Map에서 삭제한다. 성공적으로 삭제되면 true를, 그렇지 않으면 false를 반환한다.
  - `clear()` : 모든 요소를 삭제한다.
  - `forEach(callbackFn)`: 각 키-값 쌍에 대해 주어진 콜백 함수 실행한다.
 ```js
let myMap = new Map();

// 키-값 쌍 추가
myMap.set('key1', 'value1');
myMap.set('key2', 'value2');

// 값 얻기
console.log(myMap.get('key1')); // "value1"

// 키 존재 여부 확인
console.log(myMap.has('key2')); // true

// 키-값 쌍 삭제
myMap.delete('key2');

// 크기 확인
console.log(myMap.size); // 1

// 모든 요소 삭제
myMap.clear();
console.log(myMap.size); // 0
```

### 사용 상황
- 객체 요소의 순서가 중요할 때
- 키로 다양한 타입의 값을 사용해야 할 때
- 객체의 속성 이름으로 사용할 수 없는 값을 키로 사용해야 할 때

